1.顺序存储，链式存储
顺序，就是存在一起的
链式，地址并不是连续的，但是通过指针操作，将不在一起的地址连起来

2.线性表，类似列表
顺序存储的线性表称为顺序表
顺序表的实现
#define ListSize 100
typedef struct{
	DataType list[ListSize];
	int length;
}SeqList;

初始化函数
void InitList(SeqList *L)    
{
  L->length=0;	/*把线性表的长度置为0*/
}

判断是否为空的函数
int ListEmpty(SeqList L)
{
  if(L.length==0)	/*线性表的长度若为0*/
  return 1;		/*返回1*/
  else			/*否则*/
  return 0; 		/*返回0*/
}

看该位置的值的函数
int GetElem(SeqList L,int i,DataType *e)
{
  if(i<1||i>L.length)  	/*判断该序号是否合法*/
  return -1;
  *e=L.list[i-1];	      /*将第i个元素的值赋值给e*/
  return 1;
}

找第一个与e的值相等的值位置
int LocateElem(SeqList L,DataType e)
{
  int i;
  for(i=0;i<L.length;i++)	 /*从第一个元素开始与e进行比较*/
  if(L.list[i]==e) 		/*若存在与e值相等的元素*/
  return i+1;		 /*返回该元素在线性表中的序号*/
  return 0;			 /*否则，返回0*/
}

插入元素，方法，将后面的依次往后移
int InsertList(SeqList *L,int i,DataType e){
  int j;
  if(i<1||i>L->length+1)	/*在插入元素前，判断插入位置是否合法*/
  {
  printf(“插入位置i不合法！\n”); 
  return -1;
  }
  else if(L->length>=ListSize)	/*在插入元素前，判断顺序表是否已经满，不能插入元素*/
  {
    printf(“顺序表已满，不能插入元素。\n”);
    return 0;
  }
  else{
    for(j=L->length;j>=i;j--)	/*将第i个位置以后的元素依次后移*/
    L->list[j]=L->list[j-1];
    L->list[i-1]=e;		/*插入元素到第i个位置*/
    L->length=L->length+1;	/*将顺序表长增1*/
    return 1;
  }
}

删除元素的函数，具体操作是将要删除位置后面的所有的元素都往前移动
int DeleteList(SeqList *L,int i,DataType *e){
  int j;
  if(L->length<=0){
    printf(“顺序表已空不能进行删除!\n”);
    return 0;
  }else if(i<1||i>L->length){
    printf(“删除位置不合适!\n”);
    return -1;
  }else{
    *e=L->list[i-1];
    for(j=i;j<=L->length-1;j++)
      L->list[j-1]=L->list[j];
    L->length=L->length-1;
    return 1;
  }
}

2.要计算查找插入删除的操作的复杂度可以计算平均值
例如插入，在n个元素中插入一个元素，有n+1个位置，每个位置对应的操作数
是n+1-i
所以复杂度就是求和(i从1到n+1)n+1-i/n+1=n/2
所以复杂度是o(n)

依次类推，查找,删除的复杂度都是O(n)


3.链式存储
数据的物理形式和逻辑形式不一致，也就是数据不存储在一起
所以每个数据都要包含前一个数据的地址
实现
typedef struct Node{
  DataType data;
  struct Node *next;
}ListNode,*LinkList;

初始化(链表的本体是一个指针，指向头的地址，而初始化的作用就是将指向头的地址指向真正的头，为了达到这个目的
初始化函数必须申请一个单节点大小的地址。而要改变地址的值，所以传递的参数是链表指针的指针)
void InitList(LinkList *head){
  if(*head=(LinkList)malloc(sizeof(ListNode))==NULL){
    exit(-1);
  }
  (*head)->next = NULL;
}

int ListEmpty(LinkList head){
  if(head->next==NULL)
    return1;
  else
    retrun 0;
}

按序号查找
ListNode* Get(LinkList head,int t){
  ListNode *p;
  int j;
  if(i<1)
    retrun NULL;
  j=0;
  p = head;
  while(p->next!=NULL&&j<i){
    p=p->next;
    j++;
  }
  if(j==i){
    retrun p;
  }else{
    retrun NULL;
  }
}

查找元素值为e的结点
ListNode*LocateElem(LinkList head,DataType e){
  ListNode *p;
  p = head->next;
  while(p){
    if(p->data!=e)
      p=p->next;
    else
      break;
  }
  retrun p;
}

返回序号的查找e
int LocatePos(LinkList head,DataType e){
  ListNode*p;
  int i;
  if(ListEmpty(head))
    retrun 0;
  p=head-> next;
  i=1;
  while(p){
    if(p->data==e){
      retrun i;
    }else{
      p = p->next;
      i++;
    }
  }
  if(!p)
    retrun 0;
}

将e插入第i个位置
int InsertList(LinkList head,int i,DataType e){
  ListNode *pre,*p;
  int j;
  pre = head;
  j=0;
  while(pre->next!=NULL&&j<i-1){
    pre = pre->next;
    j++;
  }
  if(j!=i-1){
    printf("插入位置错误");
    retrun 0;
  }
  if((p=(ListNode*)malloc(sizeof(ListNode)))==NULL) 判断申请的内存是不是空的，百分之九九没用
    exit(-1);
  p->data = e;
  p->next = pre->next;
  pre->next = p;
  retrun 1;
}

删除第i个结点
int DeleteList(LinkList head,int i,DataType *e){
  ListNode *pre,*p;
  int j;
  pre = head;
  j=0;
  while(pre->next!=NULL&&pre->next->next!=NULL&&j<i-1){
    pre = pre-> next;
    j++;
  }
  if(j!=i-1){
    printf("删除的位置有误");
    retrun 0;
  }
  p = pre->next;
  *e = p->data;
  pre->next = p->next;
  free(p);
  retrun 1;
}

求链表长
int Listlength(LinkList head){
  ListNode* p;
  int count=0l
  p = head;
  while(p->next!=NULL){
    p = p->next;
    count ++;
  }
  retrun count;
}

销毁链表
void DestoryList(LinkList head){
  ListNode *p,*q;
  p = head;
  while(p!=NULL){
    q=p;
    p = p->next;
    free(q);
  }
}

4.循环链表
将链表的尾不再指向null而是指向head

5.双向链表
及在链表内再加一个指针指向上一个元素，而尾部直线头部，头部的指向的上一个节点指向尾部

6.算法：求两个一元方程组的乘积
看ppt